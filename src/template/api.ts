import type {
  AttributeNode,
  BaseElementNode,
  DirectiveNode,
  Node,
  RootNode,
  SourceLocation,
  TextNode,
} from '@vue/compiler-core'
import { NodeTypes } from '@vue/compiler-core'

import { isAttribute, isDirective, isNode, isText } from '~/template/utils'
import { debugTemplate } from '~/utils/debug'
import error from '~/utils/error'

/* -- SHARED UTILS -- */
const fakeSource = '_@_ generated from api, source is unavailable _@_'
let idCounter = 0
function genFakeLoc(): SourceLocation {
  idCounter += 1

  return {
    start: {
      column: 0,
      line: 0,
      offset: 0,
    },
    end: {
      column: 0,
      line: 0,
      offset: 0,
    },
    source: `${fakeSource} ${idCounter} _@_`,
  }
}

export function isGenerated(node: BaseElementNode): boolean {
  // Nodes without a SourceLocation don't come from the compiler.
  if (!node?.loc?.source) {
    return true
  }

  // Nodes with a fake SourceLocation are generated by this API.
  return node.loc.source.startsWith(fakeSource)
}

/* -- CREATE FUNCTIONS -- */
export function createDirective({
  name,
  arg,
  exp,
  modifiers = [],
}: Omit<Omit<DirectiveNode, 'loc'>, 'type'>): DirectiveNode {
  debugTemplate('api: Creating Directive', name)

  return {
    type: NodeTypes.DIRECTIVE,
    name,
    arg,
    exp,
    modifiers,
    loc: genFakeLoc(),
  }
}

export function createText({ content }: Omit<Omit<TextNode, 'loc'>, 'type'>): TextNode {
  debugTemplate('api: Creating Text', content)

  return {
    type: NodeTypes.TEXT,
    content,
    loc: genFakeLoc(),
  }
}

export function createAttribute({
  name,
  value,
}: {
  name: string
  value: string | undefined
}): AttributeNode {
  debugTemplate('api: Creating Attribute', name)

  return {
    type: NodeTypes.ATTRIBUTE,
    name,
    value: value ? createText({ content: value }) : undefined,
    loc: genFakeLoc(),
  }
}

/* -- COMPARE FUNCTIONS -- */
export function compareAttributeValues(a: AttributeNode['value'], b: AttributeNode['value']) {
  if (!a && !b) {
    return true
  }
  if (!a || !b) {
    return false
  }

  const aContent = isText(a) ? a.content : a
  const bContent = isText(b) ? b.content : b

  return aContent === bContent
}

/* -- AST EXPLORATION FUNCTIONS -- */
export function exploreAst(ast: RootNode, matcher: (node: Node) => boolean): Node[] {
  const nodeset = new Set<Node>()
  const queue: Node[] = [ast]

  while (queue.length) {
    const currentNode = queue.pop()
    if (currentNode) {
      if (matcher(currentNode)) {
        nodeset.add(currentNode)
      }

      if (typeof currentNode !== 'string') {
        const nextNodes: unknown[] = Object.values(currentNode)
          .filter(Boolean)
          .reduce((acc, current) => {
            if (Array.isArray(current)) {
              return [...acc, ...current]
            }

            return [...acc, current]
          }, [])

        queue.push(...nextNodes.filter(isNode))
      }
    }
  }

  return Array.from(nodeset)
}

export function findAstAttributes(ast: RootNode, matcher?: (node: Node) => boolean) {
  return exploreAst(ast, (node) => isAttribute(node) && (matcher?.(node) ?? true))
}

/* -- FIND FUNCTIONS -- */
export function findAttributes(
  node: BaseElementNode,
  { name, value }: Partial<Omit<Omit<AttributeNode, 'loc'>, 'type'>>,
): AttributeNode[] {
  return node.props.filter((prop) => {
    if (!isAttribute(prop)) {
      return false
    }

    if (name !== undefined && prop.name === name) {
      return true
    }

    if (value !== undefined && compareAttributeValues(prop.value, value)) {
      return true
    }

    return false
  }) as AttributeNode[]
}

export function findDirectives(
  node: BaseElementNode,
  { name, arg, exp, modifiers }: Partial<Omit<Omit<DirectiveNode, 'loc'>, 'type'>>,
): DirectiveNode[] {
  return node.props.filter((prop) => {
    if (!isDirective(prop)) {
      return false
    }

    if (name !== undefined && prop.name === name) {
      return true
    }

    if (
      modifiers !== undefined &&
      modifiers.every((mod: string) => !prop.modifiers.includes(mod))
    ) {
      return true
    }

    if (arg !== undefined) {
      throw error('findDirectives: TODO compareArgs', { arg, propArg: prop.arg })
    }
    if (exp !== undefined) {
      throw error('findDirectives: TODO compareExps', { exp, propExp: prop.exp })
    }

    return false
  }) as DirectiveNode[]
}

/* -- UPDATE FUNCTIONS -- */
export function updateAttribute(
  prop: AttributeNode,
  updater: (attr: AttributeNode) => Partial<Omit<Omit<AttributeNode, 'loc'>, 'type'>>,
) {
  /* eslint-disable no-param-reassign */
  const changes = updater(prop)

  if (Object.hasOwn(changes, 'name')) {
    if (!changes.name) {
      throw error('updateAttribute: Invalid changes to attribute name', { prop, changes })
    }
    prop.name = changes.name
  }

  if (Object.hasOwn(changes, 'value')) {
    if (
      changes.value !== undefined &&
      typeof changes.value !== 'string' &&
      !isText(changes.value)
    ) {
      throw error('updateAttribute: Invalid changes to attribute value', { prop, changes })
    }

    if (changes.value === undefined) {
      prop.value = undefined
    } else if (isText(changes.value)) {
      prop.value = changes.value
    } else {
      prop.value = createText({ content: changes.value })
    }
  }

  prop.loc = genFakeLoc()

  /* eslint-enable no-param-reassign */
  return null
}

/* -- REMOVE FUNCTIONS -- */
export function removeAttribute(
  node: BaseElementNode,
  options: Partial<Omit<Omit<AttributeNode, 'loc'>, 'type'>>,
) {
  const attributesToRemove = findAttributes(node, options)
  const filteredProps = node.props.filter(
    (prop) => !isAttribute(prop) || !attributesToRemove.includes(prop),
  )

  // eslint-disable-next-line no-param-reassign
  node.props = filteredProps
}

export function removeDirective(
  node: BaseElementNode,
  options: Partial<Omit<Omit<DirectiveNode, 'loc'>, 'type'>>,
) {
  const directivesToRemove = findDirectives(node, options)
  const filteredProps = node.props.filter(
    (prop) => !isDirective(prop) || !directivesToRemove.includes(prop),
  )

  // eslint-disable-next-line no-param-reassign
  node.props = filteredProps
}
